<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>KEG v0.7.3</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    .hp-bar {
        font-size: 14px;
        text-align: center;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        width: 80vw;
        max-width: 480px;
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        margin-bottom: 16px;
    }

    #controls .row {
        display: flex;
        gap: 4px;
    }

    #controls button {
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #222;
        color: #eee;
        cursor: pointer;
        min-width: 80px;
    }

    #controls button:active {
        background: #444;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>

<div id="game-wrapper">
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
    <div id="player-hp" class="hp-bar">Player HP: 100/100</div>
</div>

<div id="controls">
    <div class="row">
        <button id="btn-attack">âš”</button>
        <button id="btn-forward">â†‘</button>
        <button id="btn-potion">ðŸ§ª</button>
    </div>
    <div class="row">
        <button id="btn-turn-left">â†º</button>
        <button id="btn-back">â†“</button>
        <button id="btn-turn-right">â†»</button>
    </div>
</div>

<script>
/* ============================================================
   Load JSON from your GitHub assets.json (new format)
   ============================================================ */
let ASSETS = null;
let bgm = null;
let currentBgmUrl = null;
let footstepLoop = null;
let attackSound = null;
let potionSound = null;
let wallAssets = {};
let floorAssets = {};
let ceilingAssets = {};

const INITIAL_MAP_URL = "https://termcic.github.io/insect_ecology/godness.json";

async function loadAssets() {
    try {
        const res = await fetch("https://termcic.github.io/insect_ecology/assets.json");
        ASSETS = await res.json();
        console.log("Assets loaded:", ASSETS);

        // audio
        if (ASSETS.audio?.footstep) {
            footstepLoop = new Audio(ASSETS.audio.footstep);
            footstepLoop.loop = true;
            footstepLoop.volume = 0.95;
        }
        if (ASSETS.audio?.attack) {
            attackSound = new Audio(ASSETS.audio.attack);
            attackSound.loop = false;
            attackSound.volume = 0.9;
        }
        if (ASSETS.audio?.potion) {
            potionSound = new Audio(ASSETS.audio.potion);
            potionSound.loop = false;
            potionSound.volume = 0.9;
        }

    } catch (err) {
        console.error("Failed to load assets.json", err);
    }
}

let currentMapUrl = INITIAL_MAP_URL;

async function loadMaps(url = INITIAL_MAP_URL) {
    try {
        currentMapUrl = url;
        const res = await fetch(url);
        const data = await res.json();

        // size
        MAP_SIZE = data.MAP_SIZE ?? (data.wallMap?.length || 0);
        HALF_MAP = MAP_SIZE / 2;
        
        // BGM handling
        if (data.bgm) {
            // If the new map uses the same BGM URL, keep the old audio playing
            if (bgm && currentBgmUrl === data.bgm) {
                // ensure settings are correct, but do NOT reset currentTime
                bgm.loop = true;
                bgm.volume = 0.03;
            } else {
                // Different BGM or none was playing: stop old and create new
                if (bgm) {
                    bgm.pause();
                }
                bgm = new Audio(data.bgm);
                bgm.loop = true;
                bgm.volume = 0.03;
                currentBgmUrl = data.bgm;
            }
        } else {
            // This map has no BGM, stop any existing one
            if (bgm) {
                bgm.pause();
                bgm = null;
            }
            currentBgmUrl = null;
        }
        
        // light layer, fallback to all "."
        if (data.lightMap) {
            lightMap = data.lightMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            lightMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        // portal layer, fallback to all "."
        if (data.portalMap) {
            portalMap = data.portalMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            portalMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        if (data.structureMap) {
            structureMap = data.structureMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            structureMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        // portals definition (label -> { url })
        portals = data.portals || {};
        
        structuresDefs = data.structures || {};
        
        groundMap = data.groundMap;
        ceilingMap = data.ceilingMap || data.groundMap;
        wallMap = data.wallMap;
        objectMap = data.objectMap;

        // per map assets, fall back to global ASSETS if not provided
        wallAssets   = data.walls    || (ASSETS?.walls    || {});
        floorAssets  = data.floors   || (ASSETS?.floors   || {});
        ceilingAssets = data.ceilings || (ASSETS?.ceilings || {});

        console.log("Maps loaded:", {
            url,
            MAP_SIZE,
            lightMapPreview: lightMap[0],
            portalMapPreview: portalMap[0],
            structureMapPreview: structureMap[0],
            portals,
            structuresDefs,
            bgm: data.bgm,
            wallAssets,
            floorAssets,
            ceilingAssets
        });
    } catch (err) {
        console.error("Failed to load maps.json", err);
    }
}

const LIGHT_TYPES = {
    R: {
        color: new BABYLON.Color3(1.0, 0.3, 0.3),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    B: {
        color: new BABYLON.Color3(0.4, 0.6, 1.0),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    G: {
        color: new BABYLON.Color3(0.4, 1.0, 0.4),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    Y: {
        color: new BABYLON.Color3(1.0, 0.9, 0.4),
        intensity: 2.0,
        range: 15,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    W: {
        color: new BABYLON.Color3(1.0, 1.0, 1.0),
        intensity: 2.3,
        range: 15,
        angle: Math.PI / 1.2,
        exponent: 1.1
    }
};

/* ============================================================
   Base variables and DOM
   ============================================================ */

const playerHpEl = document.getElementById("player-hp");

const player = { maxHp: 100, hp: 100 };

const BASE_TORCH_INTENSITY = 1.25;
let torchTime = 0;

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let scene, camera, playerLight;

let MAP_SIZE = 0;
const TILE_SIZE = 2;
let HALF_MAP = 0;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

let wantFootsteps = false;

/* ============================================================
   MAPS - loaded from maps.json
   ============================================================ */

let groundMap = [];
let ceilingMap = [];
let wallMap = [];
let objectMap = [];
let lightMap = [];
let portalMap = [];
let structureMap = [];
let portals = {};
let structuresDefs = {};
let portalCooldown = 0;
let mapDefaultSpawn = null;

/* ============================================================
   Helpers
   ============================================================ */

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}
    
function teleportPlayerToSpawn(spawn) {
    if (!spawn) return;
    if (typeof spawn.i !== "number" || typeof spawn.j !== "number") return;

    const pos = gridToWorld(spawn.i, spawn.j);

    // only change position, do not touch rotation
    camera.position.x = pos.x;
    camera.position.y = CAMERA_HEIGHT;
    camera.position.z = pos.z;
}

function placePlayerAfterMapLoad(entrySpawn) {
    // portal spawn wins
    if (entrySpawn) {
        teleportPlayerToSpawn(entrySpawn);
        return;
    }

    // else use P from objectMap if it exists
    if (mapDefaultSpawn) {
        teleportPlayerToSpawn(mapDefaultSpawn);
        return;
    }

    // else keep current camera position
}

/* ============================================================
   Monster System with status (idle, walk, run, attack)
   ============================================================ */

const monsters = [];

/* Change monster status and switch animation sheet */
function setMonsterStatus(mon, newStatus) {
    if (mon.status === newStatus) return;

    let name = newStatus;
    let sDef = mon.statusDefs[name];

    if (!sDef) {
        if (name === "run" && mon.statusDefs.walk)        name = "walk";
        else if (name === "walk" && mon.statusDefs.idle)  name = "idle";
        else if (name === "attack" && mon.statusDefs.run) name = "run";

        sDef = mon.statusDefs[name] ||
               mon.statusDefs.idle ||
               Object.values(mon.statusDefs)[0];
    }

    if (!sDef) return;

    mon.status = name;
    mon.frames = sDef.frames;
    mon.cols = sDef.cols;
    mon.rows = sDef.rows;
    mon.animFrame = 0;
    mon.animTime = 0;

    const mat = mon.mesh.material;
    mat.diffuseTexture = sDef.texture;

    if (name === "idle")      mon.animSpeed = 3;
    else if (name === "walk") mon.animSpeed = 6;
    else if (name === "run")  mon.animSpeed = 10;
    else if (name === "attack") mon.animSpeed = 8;
}

function createMonster(scene, worldPos, type) {
    const conf = ASSETS.monsters?.[type];
    if (!conf) return null;

    const plane = BABYLON.MeshBuilder.CreatePlane(
        "monster_" + type,
        { size: conf.scale ?? 2.4 },
        scene
    );

    plane.position = new BABYLON.Vector3(worldPos.x, 1.1, worldPos.z);
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

    const mat = new BABYLON.StandardMaterial("monsterMat_" + type, scene);
    mat.backFaceCulling = false;
    mat.useAlphaFromDiffuseTexture = true;
    mat.maxSimultaneousLights = 8;
    plane.material = mat;

    const statusDefs = {};
    const statusTable = conf.status || {};

    for (const [name, sConf] of Object.entries(statusTable)) {
        const cols = sConf.cols || 1;
        const rows = sConf.rows || 1;
        const frames = sConf.frames || (cols * rows);

        const tex = new BABYLON.Texture(sConf.sprite, scene);
        tex.hasAlpha = true;
        tex.uScale = 1 / cols;
        tex.vScale = 1 / rows;
        tex.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
        tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;

        statusDefs[name] = { texture: tex, cols, rows, frames };
    }

    if (Object.keys(statusDefs).length === 0) {
        console.warn("Monster has no status animations:", type);
        return null;
    }

    const monster = {
        mesh: plane,
        type,
        hp: conf.maxHp ?? 50,
        maxHp: conf.maxHp ?? 50,
        alive: true,
        cooldown: 0,

        statusDefs,
        status: null,

        animFrame: 0,
        animTime: 0,
        animSpeed: conf.animSpeed ?? 6,
        frames: 1,
        cols: 1,
        rows: 1,

        detectRange: conf.detectRange ?? 8,
        attackRange: conf.attackRange ?? 1.5,
        walkSpeed: conf.speed ?? 1.2,
        runSpeed: conf.runSpeed ?? ((conf.speed ?? 1.2) * 1.8),
        idleRadius: conf.idleRadius ?? 3.0,

        attackDamage: conf.attackDamage ?? 4,
        radius: conf.radius ?? 0.4,

        idleCenter: plane.position.clone(),
        wanderTarget: null,
        wanderCooldown: 0
    };

    setMonsterStatus(monster, "idle");

    return monster;
}

function spawnMonsters(scene) {
    monsters.length = 0; // clear previous monsters
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const sym = objectMap[i][j];
            if (!ASSETS.monsters || !ASSETS.monsters[sym]) continue;

            const pos = gridToWorld(i, j);
            const monster = createMonster(scene, pos, sym);
            if (monster) monsters.push(monster);
        }
    }
}

function spawnStructures(scene) {
    // If the map has no structure info at all, do nothing
    if (!structureMap || !structureMap.length) return;
    if (!structuresDefs || Object.keys(structuresDefs).length === 0) {
        console.log("No structures defined for this map.");
        return;
    }

    console.log("Spawning structures...");

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const ch = structureMap[i]?.[j];
            if (!ch || ch === ".") continue;

            const sConf = structuresDefs[ch];
            if (!sConf || !sConf.url) {
                console.warn("Structure char", ch, "has no config/url");
                continue;
            }

            const pos = gridToWorld(i, j);
            const fullUrl = sConf.url;
            if (typeof fullUrl !== "string" || !fullUrl.length) continue;

            const lastSlash = fullUrl.lastIndexOf("/");
            const rootUrl   = fullUrl.substring(0, lastSlash + 1);
            const fileName  = fullUrl.substring(lastSlash + 1);

            try {
                BABYLON.SceneLoader.ImportMesh(
                    "",
                    rootUrl,
                    fileName,
                    scene,
                    (meshes) => {
                        if (!meshes || !meshes.length) {
                            console.warn("No meshes loaded for structure", ch, "at", i, j);
                            return;
                        }

                        // Same pattern as your old working code
                        const root = new BABYLON.TransformNode(
                            `struct_${ch}_${i}_${j}`,
                            scene
                        );
                        meshes.forEach(m => {
                            m.parent = root;
                        });

                        // Base position at tile center
                        root.position = new BABYLON.Vector3(
                            pos.x + (sConf.offsetX || 0),
                            0,
                            pos.z + (sConf.offsetZ || 0)
                        );

                        // Simple scale control (no TILE_SIZE magic)
                        const sc = sConf.scale ?? 1;
                        root.scaling = new BABYLON.Vector3(sc, sc, sc);

                        // Ground the model using its bounding box,
                        // exactly like in v0.1.8
                        const bbox = root.getHierarchyBoundingVectors();
                        const lowestY = bbox.min.y;
                        root.position.y -= lowestY;

                        // Optional additional vertical offset
                        if (typeof sConf.y === "number") {
                            root.position.y += sConf.y;
                        }

                        // Y-rotation if requested
                        if (typeof sConf.rotationY === "number") {
                            root.rotation = new BABYLON.Vector3(0, sConf.rotationY, 0);
                        }

                        console.log("Structure loaded", ch, "at", root.position, "scale", sc);
                    },
                    null,
                    (scene, message, exception) => {
                        console.error("ImportMesh error (async):", message, exception);
                    }
                );
            } catch (e) {
                console.error("ImportMesh error (sync):", e);
                // swallow so the map and game keep working
            }
        }
    }

    console.log("spawnStructures finished");
}

/* ============================================================
   Scene - JSON driven walls/floors/ceilings
   ============================================================ */

function createScene() {
    const scene = new BABYLON.Scene(engine);

    // camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;
    camera.minZ = 0.01;

    // ambient light
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.1;

    // torch
    playerLight = new BABYLON.PointLight(
        "playerTorch",
        new BABYLON.Vector3(0.5, 0.5, 1.1),
        scene
    );
    playerLight.parent = camera;
    playerLight.range = 12.5;
    playerLight.intensity = BASE_TORCH_INTENSITY;
    playerLight.diffuse  = new BABYLON.Color3(1.2, 0.92, 0.72);
    playerLight.specular = new BABYLON.Color3(0.35, 0.28, 0.22);
    playerLight.falloffType = BABYLON.Light.FALLOFF_STANDARD;

    const wallOps = { width: TILE_SIZE, depth: TILE_SIZE, height: WALL_HEIGHT, wrap: true };
    const floorOps = { width: TILE_SIZE, depth: TILE_SIZE, height: FLOOR_THICKNESS };
    const ceilOps  = { width: TILE_SIZE, depth: TILE_SIZE, height: CEILING_THICKNESS };

    mapDefaultSpawn = null;
    let debugLightCount = 0;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

             // FLOOR from groundMap symbol and floorAssets
            const floorChar = groundMap[i][j];
            const floorUrl  = floorAssets?.[floorChar];

            if (floorUrl) {
                const f = BABYLON.MeshBuilder.CreateBox(`f${i}_${j}`, floorOps, scene);
                f.position = new BABYLON.Vector3(pos.x, -FLOOR_THICKNESS / 2, pos.z);

                const m = new BABYLON.StandardMaterial(`fm${i}_${j}`, scene);
                m.diffuseTexture = new BABYLON.Texture(floorUrl, scene);
                m.maxSimultaneousLights = 8;
                f.material = m;
            }


            // WALL
            const tile = wallMap[i][j];
            const wallUrl = wallAssets?.[tile];

            if (wallUrl) {
                const w = BABYLON.MeshBuilder.CreateBox(`w${i}_${j}`, wallOps, scene);
                w.position = new BABYLON.Vector3(pos.x, WALL_HEIGHT / 2, pos.z);

                const mat = new BABYLON.StandardMaterial(`wm${i}_${j}`, scene);
                const tex = new BABYLON.Texture(wallUrl, scene);

                tex.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                tex.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;

                mat.diffuseTexture = tex;
                mat.specularColor = new BABYLON.Color3(0, 0, 0);
                mat.diffuseTexture.level = 0.9;
                mat.maxSimultaneousLights = 8;
                w.material = mat;
            }

            // CEILING from ceilingMap symbol and ceilingAssets
            const ceilChar = ceilingMap[i][j];
            const ceilUrl  = ceilingAssets?.[ceilChar];

            if (ceilUrl) {
                const c = BABYLON.MeshBuilder.CreateBox(`c${i}_${j}`, ceilOps, scene);
                c.position = new BABYLON.Vector3(pos.x, CEILING_Y + CEILING_THICKNESS / 2, pos.z);

                const m = new BABYLON.StandardMaterial(`cm${i}_${j}`, scene);
                m.diffuseTexture = new BABYLON.Texture(ceilUrl, scene);
                m.maxSimultaneousLights = 8;
                c.material = m;
            }

            
            // LIGHTS from lightMap
            const lightChar = lightMap[i]?.[j];
            if (lightChar && lightChar !== ".") {
                const cfg = LIGHT_TYPES[lightChar];
                if (cfg) {
                    const lightPos = new BABYLON.Vector3(pos.x, CEILING_Y - 0.1, pos.z);
                    const lightDir = new BABYLON.Vector3(0, -1, 0);

                    const light = new BABYLON.SpotLight(
                        `light_${i}_${j}`,
                        lightPos,
                        lightDir,
                        cfg.angle,
                        cfg.exponent,
                        scene
                    );

                    light.diffuse  = cfg.color;
                    light.specular = cfg.color.scale(0.4);
                    light.intensity = cfg.intensity;
                    light.range = cfg.range;
                    light.falloffType = BABYLON.Light.FALLOFF_STANDARD;

                    debugLightCount++;
                }
            }
            
            // Player spawn
            if (objectMap[i][j] === "P") {
                mapDefaultSpawn = { i, j };
            }
        }
    }

    console.log("Map lights created:", debugLightCount, "scene lights:", scene.lights.length);

    return scene;
}

/* ============================================================
   Movement + collision
   ============================================================ */

const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isObstacleTile(i, j) {
    // walls
    const wallTile = wallMap[i]?.[j];
    if (wallAssets && wallTile && (wallTile in wallAssets)) {
        return true;
    }

    // structures
    const sChar = structureMap[i]?.[j];
    if (sChar && sChar !== "." && structuresDefs && structuresDefs[sChar]) {
        const sConf = structuresDefs[sChar];
        if (sConf.solid !== false) {
            return true;
        }
    }

    return false;
}


function isCircleCollidingWithWalls(pos, radius = PLAYER_RADIUS) {
    const g = worldToGrid(pos.x, pos.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return true;

    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            const wi = g.i + di;
            const wj = g.j + dj;
            if (wi < 0 || wi >= MAP_SIZE || wj < 0 || wj >= MAP_SIZE) continue;

            // skip if there is no wall and no solid structure here
            if (!isObstacleTile(wi, wj)) continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;

            if (dx * dx + dz * dz < radius * radius) {
                return true;
            }
        }
    }
    return false;
}

function tryMove(step) {
    let moved = false;

    const px = camera.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px)) {
        camera.position.x = px.x;
        moved = true;
    }

    const pz = camera.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz)) {
        camera.position.z = pz.z;
        moved = true;
    }

    return moved;
}

function tryMoveMonster(mon, step) {
    const r = mon.radius ?? 0.4;

    const px = mon.mesh.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px, r)) {
        mon.mesh.position.x = px.x;
    }

    const pz = mon.mesh.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz, r)) {
        mon.mesh.position.z = pz.z;
    }
}

/* ============================================================
   Input
   ============================================================ */

let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward: false, back: false, left: false, right: false };

function bindHold(id, setter) {
    const b = document.getElementById(id);
    b.addEventListener("mousedown", () => setter(true));
    b.addEventListener("mouseup",   () => setter(false));
    b.addEventListener("mouseleave",() => setter(false));
    b.addEventListener("touchstart", e => { e.preventDefault(); setter(true); });
    b.addEventListener("touchend",   e => { e.preventDefault(); setter(false); });
}

bindHold("btn-forward", v => btnForwardHeld = v);
bindHold("btn-back",    v => btnBackHeld = v);
bindHold("btn-turn-left",  v => btnTurnLeftHeld = v);
bindHold("btn-turn-right", v => btnTurnRightHeld = v);

window.addEventListener("keydown", e => {
    if (e.key === "w" || e.key === "ArrowUp")    keys.forward = true;
    if (e.key === "s" || e.key === "ArrowDown")  keys.back    = true;
    if (e.key === "a" || e.key === "ArrowLeft")  keys.left    = true;
    if (e.key === "d" || e.key === "ArrowRight") keys.right   = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "w" || e.key === "ArrowUp")    keys.forward = false;
    if (e.key === "s" || e.key === "ArrowDown")  keys.back    = false;
    if (e.key === "a" || e.key === "ArrowLeft")  keys.left    = false;
    if (e.key === "d" || e.key === "ArrowRight") keys.right   = false;
});

/* ============================================================
   Attack and potion (player controls)
   ============================================================ */

document.getElementById("btn-attack").onclick = () => {
    if (attackSound) {
        attackSound.currentTime = 0;
        attackSound.play().catch(() => {});
    }

    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.hypot(dx, dz);

        if (dist < 2.2) {
            m.hp -= 12;
            if (m.hp <= 0) {
                m.alive = false;
                m.mesh.dispose();
            }
        }
    }
};

document.getElementById("btn-potion").onclick = () => {
    if (player.hp <= 0) return;

    player.hp = Math.min(player.maxHp, player.hp + 20);
    if (potionSound) {
        potionSound.currentTime = 0;
        potionSound.play().catch(() => {});
    }
};

/* ============================================================
   Monster animation (generic for any cols/rows/frames)
   ============================================================ */

function animateMonster(mon, dt) {
    if (!mon.frames || mon.frames <= 1) return;

    mon.animTime += dt;

    const frameDuration = 1 / mon.animSpeed;

    while (mon.animTime >= frameDuration) {
        mon.animFrame = (mon.animFrame + 1) % mon.frames;
        mon.animTime -= frameDuration;
    }

    const fx = mon.animFrame % mon.cols;
    const fy = Math.floor(mon.animFrame / mon.cols);

    const tex = mon.mesh.material.diffuseTexture;
    tex.uOffset = fx / mon.cols;
    tex.vOffset = fy / mon.rows;
}

/* ============================================================
   Monster AI with status
   ============================================================ */

function updateMonsterAI(mon, dt) {
    if (!mon.alive) return;

    const dx = camera.position.x - mon.mesh.position.x;
    const dz = camera.position.z - mon.mesh.position.z;
    const dist = Math.hypot(dx, dz);

    if (mon.cooldown > 0) mon.cooldown -= dt;
    if (mon.wanderCooldown > 0) mon.wanderCooldown -= dt;

    if (dist <= mon.attackRange) {
        setMonsterStatus(mon, "attack");
        mon.wanderTarget = null;

        if (mon.cooldown <= 0) {
            player.hp -= mon.attackDamage;
            if (player.hp < 0) player.hp = 0;
            mon.cooldown = 1.2;
        }
        return;
    }

    if (dist <= mon.detectRange) {
        setMonsterStatus(mon, "run");
        mon.wanderTarget = null;

        if (dist > 0.1) {
            const stepLen = mon.runSpeed * dt;
            const step = new BABYLON.Vector3((dx / dist) * stepLen, 0, (dz / dist) * stepLen);
            tryMoveMonster(mon, step);
        }
        return;
    }

    if (!mon.wanderTarget && mon.wanderCooldown <= 0) {
        if (Math.random() < 0.5) {
            setMonsterStatus(mon, "idle");
            mon.wanderCooldown = 1.5 + Math.random() * 2.0;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const radius = mon.idleRadius * Math.random();
            const tx = mon.idleCenter.x + Math.cos(angle) * radius;
            const tz = mon.idleCenter.z + Math.sin(angle) * radius;
            mon.wanderTarget = new BABYLON.Vector3(tx, mon.mesh.position.y, tz);
            setMonsterStatus(mon, "walk");
            mon.wanderCooldown = 2.0 + Math.random() * 3.0;
        }
    }

    if (mon.wanderTarget) {
        const tx = mon.wanderTarget.x - mon.mesh.position.x;
        const tz = mon.wanderTarget.z - mon.mesh.position.z;
        const dTarget = Math.hypot(tx, tz);

        if (dTarget < 0.1 || mon.wanderCooldown <= 0) {
            mon.wanderTarget = null;
        } else {
            const stepLen = mon.walkSpeed * dt;
            const step = new BABYLON.Vector3((tx / dTarget) * stepLen, 0, (tz / dTarget) * stepLen);
            tryMoveMonster(mon, step);
        }
    }
}

/* ============================================================
   Portals
   ============================================================ */

async function switchMap(portalCfg) {
    if (!portalCfg || !portalCfg.url) return;
    console.log("Switching map to", portalCfg.url, "spawn:", portalCfg.spawn);

    let preservedYaw = camera ? camera.rotation.y : 0;
    
    monsters.length = 0;
    
    if (scene) {
        scene.dispose();
    }

    await loadMaps(portalCfg.url);
    scene = createScene();

    camera.rotation.y = preservedYaw;
    
    spawnMonsters(scene);
    spawnStructures(scene);
    
    // portal spawn has priority over 'P'
    placePlayerAfterMapLoad(portalCfg.spawn);

    portalCooldown = 0.5;
}

function checkPortal() {
    if (portalCooldown > 0) return;
    if (!portalMap.length) return;

    const g = worldToGrid(camera.position.x, camera.position.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return;

    const ch = portalMap[g.i]?.[g.j];
    if (!ch || ch === ".") return;

    const portalCfg = portals[ch];
    if (!portalCfg || !portalCfg.url) return;

    switchMap(portalCfg);
}

/* ============================================================
   Game Loop
   ============================================================ */

function update(dt) {
    if (portalCooldown > 0) {
        portalCooldown -= dt;
        if (portalCooldown < 0) portalCooldown = 0;
    }

    if (btnTurnLeftHeld || keys.left)  camera.rotation.y -= TURN_SPEED * dt;
    if (btnTurnRightHeld || keys.right)camera.rotation.y += TURN_SPEED * dt;

    const fwd = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flat = new BABYLON.Vector3(fwd.x, 0, fwd.z).normalize();
    const step = MOVE_SPEED * dt;

    let moved = false;
    if (btnForwardHeld || keys.forward) moved |= tryMove(flat.scale(step));
    if (btnBackHeld    || keys.back   ) moved |= tryMove(flat.scale(-step));

    wantFootsteps = moved;
    if (footstepLoop) {
        if (wantFootsteps && footstepLoop.paused) footstepLoop.play().catch(() => {});
        if (!wantFootsteps && !footstepLoop.paused) footstepLoop.pause();
    }

    // check portal after movement
    checkPortal();

    // torch flicker
    torchTime += dt;
    const flicker =
        Math.sin(torchTime * 6.3) * 0.08 +
        Math.sin(torchTime * 11.1) * 0.05 +
        (Math.random() - 0.5) * 0.02;
    let intensity = BASE_TORCH_INTENSITY + flicker;
    intensity = Math.min(1.6, Math.max(0.95, intensity));
    playerLight.intensity = intensity;

    for (const m of monsters) {
        updateMonsterAI(m, dt);
        if (m.alive) animateMonster(m, dt);
    }

    playerHpEl.textContent = `Player HP: ${player.hp}/${player.maxHp}`;
}

/* ============================================================
   Start the game
   ============================================================ */

(async () => {
    await loadAssets();
    await loadMaps(INITIAL_MAP_URL);

    scene = createScene();
    spawnMonsters(scene);
    spawnStructures(scene);

    placePlayerAfterMapLoad(null);

    engine.runRenderLoop(() => {
        const dt = engine.getDeltaTime() / 1000;
        update(dt);
        scene.render();

        if (bgm && bgm.paused) bgm.play().catch(() => {});
    });
})();

window.addEventListener("resize", () => engine.resize());
window.addEventListener("click", () => {
    if (bgm && bgm.paused) bgm.play().catch(() => {});
});
</script>


</body>
</html>
