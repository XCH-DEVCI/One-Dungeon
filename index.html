<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>ONE Dungeon v0.8.3</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>
    body {
        margin: 0;
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        height: -webkit-fill-available;
        gap: 8px;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    #game-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
    }

    #game {
        position: relative;
        overflow: hidden;
        background: black;
        border: 4px solid #555;
        aspect-ratio: 1 / 1;
        /* size will be set by JS */
    }

    #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>

<body>

<div id="game-wrapper">
    <div id="game">
        <canvas id="renderCanvas"></canvas>
    </div>
</div>

<script>
function resizeGameSquare() {
    const gameDiv = document.getElementById("game");
    if (!gameDiv) return;

    const vw = window.innerWidth;
    const vh = window.innerHeight;

    // portrait: use width, landscape: use height
    let size;
    if (vh >= vw) {
        // portrait or square
        size = vw;
    } else {
        // landscape
        size = vh;
    }

    gameDiv.style.width  = size + "px";
    gameDiv.style.height = size + "px";
}

/* ============================================================
   Load JSON from your GitHub assets.json (new format)
   ============================================================ */
let ASSETS = null;
let bgm = null;
let currentBgmUrl = null;
let footstepLoop = null;
let attackSound = null;
let potionSound = null;
let wallAssets = {};
let floorAssets = {};
let ceilingAssets = {};

const INITIAL_MAP_URL = "https://xch-devci.github.io/One-Dungeon/maps/godness.json";

async function loadAssets() {
    try {
        const res = await fetch("https://xch-devci.github.io/One-Dungeon/assets/assets.json");
        ASSETS = await res.json();
        console.log("Assets loaded:", ASSETS);

        // audio
        if (ASSETS.audio?.footstep) {
            footstepLoop = new Audio(ASSETS.audio.footstep);
            footstepLoop.loop = true;
            footstepLoop.volume = 0.95;
        }
        if (ASSETS.audio?.attack) {
            attackSound = new Audio(ASSETS.audio.attack);
            attackSound.loop = false;
            attackSound.volume = 0.9;
        }
        if (ASSETS.audio?.potion) {
            potionSound = new Audio(ASSETS.audio.potion);
            potionSound.loop = false;
            potionSound.volume = 0.9;
        }

    } catch (err) {
        console.error("Failed to load assets.json", err);
    }
}

let currentMapUrl = INITIAL_MAP_URL;

async function loadMaps(url = INITIAL_MAP_URL) {
    try {
        currentMapUrl = url;
        const res = await fetch(url);
        const data = await res.json();

        // size
        MAP_SIZE = data.MAP_SIZE ?? (data.wallMap?.length || 0);
        HALF_MAP = MAP_SIZE / 2;
        
        // BGM handling
        if (data.bgm) {
            // If the new map uses the same BGM URL, keep the old audio playing
            if (bgm && currentBgmUrl === data.bgm) {
                bgm.loop = true;
                bgm.volume = 0.03;
            } else {
                if (bgm) {
                    bgm.pause();
                }
                bgm = new Audio(data.bgm);
                bgm.loop = true;
                bgm.volume = 0.03;
                currentBgmUrl = data.bgm;
            }
        } else {
            if (bgm) {
                bgm.pause();
                bgm = null;
            }
            currentBgmUrl = null;
        }
        
        // light layer, fallback to all "."
        if (data.lightMap) {
            lightMap = data.lightMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            lightMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        // portal layer, fallback to all "."
        if (data.portalMap) {
            portalMap = data.portalMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            portalMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        if (data.structureMap) {
            structureMap = data.structureMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            structureMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        // portals definition (label -> { url })
        portals = data.portals || {};
        
        structuresDefs = data.structures || {};
        
        groundMap = data.groundMap;
        ceilingMap = data.ceilingMap || data.groundMap;
        wallMap = data.wallMap;
        objectMap = data.objectMap;

        // per map assets, fall back to global ASSETS if not provided
        wallAssets   = data.walls    || (ASSETS?.walls    || {});
        floorAssets  = data.floors   || (ASSETS?.floors   || {});
        ceilingAssets = data.ceilings || (ASSETS?.ceilings || {});

        console.log("Maps loaded:", {
            url,
            MAP_SIZE,
            lightMapPreview: lightMap[0],
            portalMapPreview: portalMap[0],
            structureMapPreview: structureMap[0],
            portals,
            structuresDefs,
            bgm: data.bgm,
            wallAssets,
            floorAssets,
            ceilingAssets
        });
    } catch (err) {
        console.error("Failed to load maps.json", err);
    }
}

const LIGHT_TYPES = {
    R: {
        color: new BABYLON.Color3(1.0, 0.3, 0.3),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    B: {
        color: new BABYLON.Color3(0.4, 0.6, 1.0),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    G: {
        color: new BABYLON.Color3(0.4, 1.0, 0.4),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    Y: {
        color: new BABYLON.Color3(1.0, 0.9, 0.4),
        intensity: 2.0,
        range: 15,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    W: {
        color: new BABYLON.Color3(1.0, 1.0, 1.0),
        intensity: 2.3,
        range: 15,
        angle: Math.PI / 1.2,
        exponent: 1.1
    }
};

/* ============================================================
   Base variables and Babylon setup
   ============================================================ */

const player = { maxHp: 100, hp: 100 };

const BASE_TORCH_INTENSITY = 1.25;
let torchTime = 0;

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
engine.setHardwareScalingLevel(1.3);

let scene, camera, playerLight;

let MAP_SIZE = 0;
const TILE_SIZE = 2;
let HALF_MAP = 0;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

let wantFootsteps = false;

/* GUI elements (Babylon GUI) */
let guiTexture = null;
let hpText = null;

/* ============================================================
   MAPS - loaded from maps.json
   ============================================================ */

let groundMap = [];
let ceilingMap = [];
let wallMap = [];
let objectMap = [];
let lightMap = [];
let portalMap = [];
let structureMap = [];
let portals = {};
let structuresDefs = {};
let portalCooldown = 0;
let mapDefaultSpawn = null;

/* ============================================================
   Helpers
   ============================================================ */

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}
    
function teleportPlayerToSpawn(spawn) {
    if (!spawn) return;
    if (typeof spawn.i !== "number" || typeof spawn.j !== "number") return;

    const pos = gridToWorld(spawn.i, spawn.j);

    camera.position.x = pos.x;
    camera.position.y = CAMERA_HEIGHT;
    camera.position.z = pos.z;
}

function placePlayerAfterMapLoad(entrySpawn) {
    if (entrySpawn) {
        teleportPlayerToSpawn(entrySpawn);
        return;
    }

    if (mapDefaultSpawn) {
        teleportPlayerToSpawn(mapDefaultSpawn);
        return;
    }
}

/* ============================================================
   Monster System with status (idle, walk, run, attack)
   ============================================================ */

const monsters = [];

function setMonsterStatus(mon, newStatus) {
    if (mon.status === newStatus) return;

    let name = newStatus;
    let sDef = mon.statusDefs[name];

    if (!sDef) {
        if (name === "run" && mon.statusDefs.walk)        name = "walk";
        else if (name === "walk" && mon.statusDefs.idle)  name = "idle";
        else if (name === "attack" && mon.statusDefs.run) name = "run";

        sDef = mon.statusDefs[name] ||
               mon.statusDefs.idle ||
               Object.values(mon.statusDefs)[0];
    }

    if (!sDef) return;

    mon.status = name;
    mon.frames = sDef.frames;
    mon.cols = sDef.cols;
    mon.rows = sDef.rows;
    mon.animFrame = 0;
    mon.animTime = 0;

    const mat = mon.mesh.material;
    mat.diffuseTexture = sDef.texture;

    if (name === "idle")      mon.animSpeed = 3;
    else if (name === "walk") mon.animSpeed = 6;
    else if (name === "run")  mon.animSpeed = 10;
    else if (name === "attack") mon.animSpeed = 8;
}

function createMonster(scene, worldPos, type) {
    const conf = ASSETS.monsters?.[type];
    if (!conf) return null;

    const plane = BABYLON.MeshBuilder.CreatePlane(
        "monster_" + type,
        { size: conf.scale ?? 2.4 },
        scene
    );

    plane.position = new BABYLON.Vector3(worldPos.x, 1.1, worldPos.z);
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

    const mat = new BABYLON.StandardMaterial("monsterMat_" + type, scene);
    mat.backFaceCulling = false;
    mat.useAlphaFromDiffuseTexture = true;
    mat.maxSimultaneousLights = 8;
    plane.material = mat;

    const statusDefs = {};
    const statusTable = conf.status || {};

    for (const [name, sConf] of Object.entries(statusTable)) {
        const cols = sConf.cols || 1;
        const rows = sConf.rows || 1;
        const frames = sConf.frames || (cols * rows);

        const tex = new BABYLON.Texture(sConf.sprite, scene);
        tex.hasAlpha = true;
        tex.uScale = 1 / cols;
        tex.vScale = 1 / rows;
        tex.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
        tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;

        statusDefs[name] = { texture: tex, cols, rows, frames };
    }

    if (Object.keys(statusDefs).length === 0) {
        console.warn("Monster has no status animations:", type);
        return null;
    }

    const monster = {
        mesh: plane,
        type,
        hp: conf.maxHp ?? 50,
        maxHp: conf.maxHp ?? 50,
        alive: true,
        cooldown: 0,

        statusDefs,
        status: null,

        animFrame: 0,
        animTime: 0,
        animSpeed: conf.animSpeed ?? 6,
        frames: 1,
        cols: 1,
        rows: 1,

        detectRange: conf.detectRange ?? 8,
        attackRange: conf.attackRange ?? 1.5,
        walkSpeed: conf.speed ?? 1.2,
        runSpeed: conf.runSpeed ?? ((conf.speed ?? 1.2) * 1.8),
        idleRadius: conf.idleRadius ?? 3.0,

        attackDamage: conf.attackDamage ?? 4,
        radius: conf.radius ?? 0.4,

        idleCenter: plane.position.clone(),
        wanderTarget: null,
        wanderCooldown: 0
    };

    setMonsterStatus(monster, "idle");

    return monster;
}

function spawnMonsters(scene) {
    monsters.length = 0;
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const sym = objectMap[i][j];
            if (!ASSETS.monsters || !ASSETS.monsters[sym]) continue;

            const pos = gridToWorld(i, j);
            const monster = createMonster(scene, pos, sym);
            if (monster) monsters.push(monster);
        }
    }
}

function spawnStructures(scene) {
    if (!structureMap || !structureMap.length) return;
    if (!structuresDefs || Object.keys(structuresDefs).length === 0) {
        console.log("No structures defined for this map.");
        return;
    }

    console.log("Spawning structures...");

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const ch = structureMap[i]?.[j];
            if (!ch || ch === ".") continue;

            const sConf = structuresDefs[ch];
            if (!sConf || !sConf.url) {
                console.warn("Structure char", ch, "has no config/url");
                continue;
            }

            const pos = gridToWorld(i, j);
            const fullUrl = sConf.url;
            if (typeof fullUrl !== "string" || !fullUrl.length) continue;

            const lastSlash = fullUrl.lastIndexOf("/");
            const rootUrl   = fullUrl.substring(0, lastSlash + 1);
            const fileName  = fullUrl.substring(lastSlash + 1);

            try {
                BABYLON.SceneLoader.ImportMesh(
                    "",
                    rootUrl,
                    fileName,
                    scene,
                    (meshes) => {
                        if (!meshes || !meshes.length) {
                            console.warn("No meshes loaded for structure", ch, "at", i, j);
                            return;
                        }

                        const root = new BABYLON.TransformNode(
                            `struct_${ch}_${i}_${j}`,
                            scene
                        );
                        meshes.forEach(m => {
                            m.parent = root;
                        });

                        const basePos = pos;
                        root.position = new BABYLON.Vector3(
                            basePos.x + (sConf.offsetX || 0),
                            0,
                            basePos.z + (sConf.offsetZ || 0)
                        );

                        const sc = sConf.scale ?? 1;
                        root.scaling = new BABYLON.Vector3(sc, sc, sc);

                        const bbox = root.getHierarchyBoundingVectors();
                        const lowestY = bbox.min.y;
                        root.position.y -= lowestY;

                        if (typeof sConf.y === "number") {
                            root.position.y += sConf.y;
                        }

                        if (typeof sConf.rotationY === "number") {
                            root.rotation = new BABYLON.Vector3(0, sConf.rotationY, 0);
                        }

                        console.log("Structure loaded", ch, "at", root.position, "scale", sc);
                    },
                    null,
                    (scene, message, exception) => {
                        console.error("ImportMesh error (async):", message, exception);
                    }
                );
            } catch (e) {
                console.error("ImportMesh error (sync):", e);
            }
        }
    }

    console.log("spawnStructures finished");
}

/* ============================================================
   Scene - JSON driven walls/floors/ceilings
   plus Babylon GUI for HP + buttons
   ============================================================ */

function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    // --- SKYBOX START ---
    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {
        size: 200
    }, scene);

    const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.disableLighting = true;

    const base = "https://xch-devci.github.io/One-Dungeon/assets/sky/";

    const skyTexture = BABYLON.CubeTexture.CreateFromImages([
        base + "Night Moon Burst_Cam_2_Left+X.png",
        base + "Night Moon Burst_Cam_4_Up+Y.png",
        base + "Night Moon Burst_Cam_0_Front+Z.png",
        base + "Night Moon Burst_Cam_3_Right-X.png",
        base + "Night Moon Burst_Cam_5_Down-Y.png",
        base + "Night Moon Burst_Cam_1_Back-Z.png"
    ], scene);

    skyTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.reflectionTexture = skyTexture;
    skybox.material = skyboxMaterial;
    // --- SKYBOX END ---
    
    // camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;
    camera.minZ = 0.01;

    // lights
    const sun = new BABYLON.DirectionalLight(
        "sunLight",
        new BABYLON.Vector3(-0.3, -1.0, -0.2),
        scene
    );
    sun.position = new BABYLON.Vector3(0, 50, 0);
    sun.intensity = 0.4;
    sun.diffuse  = new BABYLON.Color3(1.0, 0.98, 0.9);
    sun.specular = new BABYLON.Color3(1.0, 1.0, 1.0);
    
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.1;

    playerLight = new BABYLON.PointLight(
        "playerTorch",
        new BABYLON.Vector3(0.5, 0.5, 1.1),
        scene
    );
    playerLight.parent = camera;
    playerLight.range = 12.5;
    playerLight.intensity = BASE_TORCH_INTENSITY;
    playerLight.diffuse  = new BABYLON.Color3(1.2, 0.92, 0.72);
    playerLight.specular = new BABYLON.Color3(0.35, 0.28, 0.22);
    playerLight.falloffType = BABYLON.Light.FALLOFF_STANDARD;

    const wallOps = { width: TILE_SIZE, depth: TILE_SIZE, height: WALL_HEIGHT, wrap: true };
    const floorOps = { width: TILE_SIZE, depth: TILE_SIZE, height: FLOOR_THICKNESS };
    const ceilOps  = { width: TILE_SIZE, depth: TILE_SIZE, height: CEILING_THICKNESS };

    mapDefaultSpawn = null;
    let debugLightCount = 0;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            // FLOOR
            const floorChar = groundMap[i][j];
            const floorUrl  = floorAssets?.[floorChar];
            if (floorUrl) {
                const f = BABYLON.MeshBuilder.CreateBox(`f${i}_${j}`, floorOps, scene);
                f.position = new BABYLON.Vector3(pos.x, -FLOOR_THICKNESS / 2, pos.z);
            
                const m = new BABYLON.StandardMaterial(`fm${i}_${j}`, scene);
                m.diffuseTexture = new BABYLON.Texture(floorUrl, scene);
                m.maxSimultaneousLights = 8;
                f.material = m;
            }

            // WALL
            const tile = wallMap[i][j];
            const wallUrl = wallAssets?.[tile];
            if (wallUrl) {
                const w = BABYLON.MeshBuilder.CreateBox(`w${i}_${j}`, wallOps, scene);
                w.position = new BABYLON.Vector3(pos.x, WALL_HEIGHT / 2, pos.z);
            
                const mat = new BABYLON.StandardMaterial(`wm${i}_${j}`, scene);
                const tex = new BABYLON.Texture(wallUrl, scene);
            
                tex.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                tex.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
            
                mat.diffuseTexture = tex;
                mat.specularColor = new BABYLON.Color3(0, 0, 0);
                mat.diffuseTexture.level = 0.9;
                mat.maxSimultaneousLights = 8;
                w.material = mat;
            }

            // CEILING
            const ceilChar = ceilingMap[i][j];
            const ceilUrl  = ceilingAssets?.[ceilChar];
            if (ceilUrl) {
                const c = BABYLON.MeshBuilder.CreateBox(`c${i}_${j}`, ceilOps, scene);
                c.position = new BABYLON.Vector3(pos.x, CEILING_Y + CEILING_THICKNESS / 2, pos.z);
            
                const m = new BABYLON.StandardMaterial(`cm${i}_${j}`, scene);
                m.diffuseTexture = new BABYLON.Texture(ceilUrl, scene);
                m.maxSimultaneousLights = 8;
                c.material = m;
            }

            // LIGHTS from lightMap
            const lightChar = lightMap[i]?.[j];
            if (lightChar && lightChar !== ".") {
                const cfg = LIGHT_TYPES[lightChar];
                if (cfg) {
                    const lightPos = new BABYLON.Vector3(pos.x, CEILING_Y - 0.1, pos.z);
                    const lightDir = new BABYLON.Vector3(0, -1, 0);

                    const light = new BABYLON.SpotLight(
                        `light_${i}_${j}`,
                        lightPos,
                        lightDir,
                        cfg.angle,
                        cfg.exponent,
                        scene
                    );

                    light.diffuse  = cfg.color;
                    light.specular = cfg.color.scale(0.4);
                    light.intensity = cfg.intensity;
                    light.range = cfg.range;
                    light.falloffType = BABYLON.Light.FALLOFF_STANDARD;

                    debugLightCount++;
                }
            }
            
            // Player spawn
            if (objectMap[i][j] === "P") {
                mapDefaultSpawn = { i, j };
            }
        }
    }

    console.log("Map lights created:", debugLightCount, "scene lights:", scene.lights.length);

    /* ---------------- Babylon GUI: HP text and buttons ---------------- */

    guiTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene);

    // HP text at top center
    hpText = new BABYLON.GUI.TextBlock("hpText", "Player HP: 100/100");
    hpText.color = "white";
    hpText.fontSize = 24;
    hpText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    hpText.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
    hpText.paddingTop = "10px";
    guiTexture.addControl(hpText);

    // bottom control panel
    const panel = new BABYLON.GUI.StackPanel();
    panel.isVertical = true;
    panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    panel.paddingBottom = "20px";
    guiTexture.addControl(panel);

    // helper to create hold buttons
    function createHoldButton(name, label, onDown, onUp) {
        const btn = BABYLON.GUI.Button.CreateSimpleButton(name, label);
        btn.width = "64px";
        btn.height = "64px";
        btn.fontSize = 28;
        btn.color = "white";
        btn.thickness = 1;
        btn.background = "#222222";

        btn.onPointerDownObservable.add(() => onDown(true));
        const release = () => onUp(false);
        btn.onPointerUpObservable.add(release);
        btn.onPointerOutObservable.add(release);

        return btn;
    }

    // helper to create tap buttons (attack, potion)
    function createTapButton(name, label, onTap) {
        const btn = BABYLON.GUI.Button.CreateSimpleButton(name, label);
        btn.width = "64px";
        btn.height = "64px";
        btn.fontSize = 28;
        btn.color = "white";
        btn.thickness = 1;
        btn.background = "#222222";

        btn.onPointerUpObservable.add(() => onTap());

        return btn;
    }

    // first row: attack, forward, potion
    const row1 = new BABYLON.GUI.StackPanel();
    row1.isVertical = false;
    row1.height = "70px";
    row1.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    panel.addControl(row1);

    const btnAttack = createTapButton("btnAttack", "âš”", performAttack);
    const btnForward = createHoldButton(
        "btnForward", "â†‘",
        v => btnForwardHeld = v,
        v => btnForwardHeld = v
    );
    const btnPotion = createTapButton("btnPotion", "ðŸ§ª", performPotion);

    row1.addControl(btnAttack);
    row1.addControl(btnForward);
    row1.addControl(btnPotion);

    // second row: turn left, back, turn right
    const row2 = new BABYLON.GUI.StackPanel();
    row2.isVertical = false;
    row2.height = "70px";
    row2.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    panel.addControl(row2);

    const btnTurnLeft = createHoldButton(
        "btnTurnLeft", "â†º",
        v => btnTurnLeftHeld = v,
        v => btnTurnLeftHeld = v
    );
    const btnBack = createHoldButton(
        "btnBack", "â†“",
        v => btnBackHeld = v,
        v => btnBackHeld = v
    );
    const btnTurnRight = createHoldButton(
        "btnTurnRight", "â†»",
        v => btnTurnRightHeld = v,
        v => btnTurnRightHeld = v
    );

    row2.addControl(btnTurnLeft);
    row2.addControl(btnBack);
    row2.addControl(btnTurnRight);

    return scene;
}

/* ============================================================
   Movement + collision
   ============================================================ */

const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isObstacleTile(i, j) {
    const wallTile = wallMap[i]?.[j];
    if (wallAssets && wallTile && (wallTile in wallAssets)) {
        return true;
    }

    const sChar = structureMap[i]?.[j];
    if (sChar && sChar !== "." && structuresDefs && structuresDefs[sChar]) {
        const sConf = structuresDefs[sChar];
        if (sConf.solid !== false) {
            return true;
        }
    }

    return false;
}

function isCircleCollidingWithWalls(pos, radius = PLAYER_RADIUS) {
    const g = worldToGrid(pos.x, pos.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return true;

    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            const wi = g.i + di;
            const wj = g.j + dj;
            if (wi < 0 || wi >= MAP_SIZE || wj < 0 || wj >= MAP_SIZE) continue;

            if (!isObstacleTile(wi, wj)) continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;

            if (dx * dx + dz * dz < radius * radius) {
                return true;
            }
        }
    }
    return false;
}

function tryMove(step) {
    let moved = false;

    const px = camera.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px)) {
        camera.position.x = px.x;
        moved = true;
    }

    const pz = camera.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz)) {
        camera.position.z = pz.z;
        moved = true;
    }

    return moved;
}

function tryMoveMonster(mon, step) {
    const r = mon.radius ?? 0.4;

    const px = mon.mesh.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px, r)) {
        mon.mesh.position.x = px.x;
    }

    const pz = mon.mesh.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz, r)) {
        mon.mesh.position.z = pz.z;
    }
}

/* ============================================================
   Input
   ============================================================ */

let btnForwardHeld = false,
    btnBackHeld = false,
    btnTurnLeftHeld = false,
    btnTurnRightHeld = false;

const keys = { forward: false, back: false, left: false, right: false };

window.addEventListener("keydown", e => {
    if (e.key === "w" || e.key === "ArrowUp")    keys.forward = true;
    if (e.key === "s" || e.key === "ArrowDown")  keys.back    = true;
    if (e.key === "a" || e.key === "ArrowLeft")  keys.left    = true;
    if (e.key === "d" || e.key === "ArrowRight") keys.right   = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "w" || e.key === "ArrowUp")    keys.forward = false;
    if (e.key === "s" || e.key === "ArrowDown")  keys.back    = false;
    if (e.key === "a" || e.key === "ArrowLeft")  keys.left    = false;
    if (e.key === "d" || e.key === "ArrowRight") keys.right   = false;
});

/* ============================================================
   Attack and potion actions
   ============================================================ */

function performAttack() {
    if (attackSound) {
        attackSound.currentTime = 0;
        attackSound.play().catch(() => {});
    }

    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.hypot(dx, dz);

        if (dist < 2.2) {
            m.hp -= 12;
            if (m.hp <= 0) {
                m.alive = false;
                m.mesh.dispose();
            }
        }
    }
}

function performPotion() {
    if (player.hp <= 0) return;

    player.hp = Math.min(player.maxHp, player.hp + 20);
    if (potionSound) {
        potionSound.currentTime = 0;
        potionSound.play().catch(() => {});
    }
}

/* ============================================================
   Monster animation
   ============================================================ */

function animateMonster(mon, dt) {
    if (!mon.frames || mon.frames <= 1) return;

    mon.animTime += dt;

    const frameDuration = 1 / mon.animSpeed;

    while (mon.animTime >= frameDuration) {
        mon.animFrame = (mon.animFrame + 1) % mon.frames;
        mon.animTime -= frameDuration;
    }

    const fx = mon.animFrame % mon.cols;
    const fy = Math.floor(mon.animFrame / mon.cols);

    const tex = mon.mesh.material.diffuseTexture;
    tex.uOffset = fx / mon.cols;
    tex.vOffset = fy / mon.rows;
}

/* ============================================================
   Monster AI with status
   ============================================================ */

function updateMonsterAI(mon, dt) {
    if (!mon.alive) return;

    const dx = camera.position.x - mon.mesh.position.x;
    const dz = camera.position.z - mon.mesh.position.z;
    const dist = Math.hypot(dx, dz);

    if (mon.cooldown > 0) mon.cooldown -= dt;
    if (mon.wanderCooldown > 0) mon.wanderCooldown -= dt;

    if (dist <= mon.attackRange) {
        setMonsterStatus(mon, "attack");
        mon.wanderTarget = null;

        if (mon.cooldown <= 0) {
            player.hp -= mon.attackDamage;
            if (player.hp < 0) player.hp = 0;
            mon.cooldown = 1.2;
        }
        return;
    }

    if (dist <= mon.detectRange) {
        setMonsterStatus(mon, "run");
        mon.wanderTarget = null;

        if (dist > 0.1) {
            const stepLen = mon.runSpeed * dt;
            const step = new BABYLON.Vector3((dx / dist) * stepLen, 0, (dz / dist) * stepLen);
            tryMoveMonster(mon, step);
        }
        return;
    }

    if (!mon.wanderTarget && mon.wanderCooldown <= 0) {
        if (Math.random() < 0.5) {
            setMonsterStatus(mon, "idle");
            mon.wanderCooldown = 1.5 + Math.random() * 2.0;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const radius = mon.idleRadius * Math.random();
            const tx = mon.idleCenter.x + Math.cos(angle) * radius;
            const tz = mon.idleCenter.z + Math.sin(angle) * radius;
            mon.wanderTarget = new BABYLON.Vector3(tx, mon.mesh.position.y, tz);
            setMonsterStatus(mon, "walk");
            mon.wanderCooldown = 2.0 + Math.random() * 3.0;
        }
    }

    if (mon.wanderTarget) {
        const tx = mon.wanderTarget.x - mon.mesh.position.x;
        const tz = mon.wanderTarget.z - mon.mesh.position.z;
        const dTarget = Math.hypot(tx, tz);

        if (dTarget < 0.1 || mon.wanderCooldown <= 0) {
            mon.wanderTarget = null;
        } else {
            const stepLen = mon.walkSpeed * dt;
            const step = new BABYLON.Vector3((tx / dTarget) * stepLen, 0, (tz / dTarget) * stepLen);
            tryMoveMonster(mon, step);
        }
    }
}

/* ============================================================
   Portals
   ============================================================ */

async function switchMap(portalCfg) {
    if (!portalCfg || !portalCfg.url) return;
    console.log("Switching map to", portalCfg.url, "spawn:", portalCfg.spawn);

    let preservedYaw = camera ? camera.rotation.y : 0;
    
    monsters.length = 0;
    
    if (scene) {
        scene.dispose();
    }

    await loadMaps(portalCfg.url);
    scene = createScene();

    camera.rotation.y = preservedYaw;
    
    spawnMonsters(scene);
    spawnStructures(scene);
    
    placePlayerAfterMapLoad(portalCfg.spawn);

    portalCooldown = 0.5;
}

function checkPortal() {
    if (portalCooldown > 0) return;
    if (!portalMap.length) return;

    const g = worldToGrid(camera.position.x, camera.position.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return;

    const ch = portalMap[g.i]?.[g.j];
    if (!ch || ch === ".") return;

    const portalCfg = portals[ch];
    if (!portalCfg || !portalCfg.url) return;

    switchMap(portalCfg);
}

/* ============================================================
   Game Loop
   ============================================================ */

function update(dt) {
    if (portalCooldown > 0) {
        portalCooldown -= dt;
        if (portalCooldown < 0) portalCooldown = 0;
    }

    if (btnTurnLeftHeld || keys.left)  camera.rotation.y -= TURN_SPEED * dt;
    if (btnTurnRightHeld || keys.right)camera.rotation.y += TURN_SPEED * dt;

    const fwd = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flat = new BABYLON.Vector3(fwd.x, 0, fwd.z).normalize();
    const step = MOVE_SPEED * dt;

    let moved = false;
    if (btnForwardHeld || keys.forward) moved |= tryMove(flat.scale(step));
    if (btnBackHeld    || keys.back   ) moved |= tryMove(flat.scale(-step));

    wantFootsteps = moved;
    if (footstepLoop) {
        if (wantFootsteps && footstepLoop.paused) footstepLoop.play().catch(() => {});
        if (!wantFootsteps && !footstepLoop.paused) footstepLoop.pause();
    }

    checkPortal();

    torchTime += dt;
    const flicker =
        Math.sin(torchTime * 6.3) * 0.08 +
        Math.sin(torchTime * 11.1) * 0.05 +
        (Math.random() - 0.5) * 0.02;
    let intensity = BASE_TORCH_INTENSITY + flicker;
    intensity = Math.min(1.6, Math.max(0.95, intensity));
    playerLight.intensity = intensity;

    for (const m of monsters) {
        updateMonsterAI(m, dt);
        if (m.alive) animateMonster(m, dt);
    }

    if (hpText) {
        hpText.text = `Player HP: ${player.hp}/${player.maxHp}`;
    }
}

/* ============================================================
   Start the game
   ============================================================ */

(async () => {
    await loadAssets();
    await loadMaps(INITIAL_MAP_URL);

    scene = createScene();
    spawnMonsters(scene);
    spawnStructures(scene);

    placePlayerAfterMapLoad(null);

    engine.runRenderLoop(() => {
        const dt = engine.getDeltaTime() / 1000;
        update(dt);
        scene.render();

        if (bgm && bgm.paused) bgm.play().catch(() => {});
    });
})();

window.addEventListener("resize", () => engine.resize());
window.addEventListener("click", () => {
    if (bgm && bgm.paused) bgm.play().catch(() => {});
});
window.addEventListener("resize", () => {
    resizeGameSquare();   // adjust square size based on orientation
});
</script>

</body>
</html>
