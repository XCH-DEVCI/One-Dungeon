<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>ONE Dungeon v1.0.6</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
        font-family: system-ui, sans-serif;
        color: #eee;
    }

    /* Fullscreen canvas game */
    #renderCanvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: black;

    /* Èò≤Ê≠¢ÈÅ∏Âèñ„ÄÅÈï∑ÊåâËèúÂñÆ„ÄÅÈõôÊìäÊîæÂ§ß */
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
}

</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>

<body>

<canvas id="renderCanvas"></canvas>

<script>
/* ============================================================
   Load JSON from your GitHub assets.json (new format)
   ============================================================ */
let ASSETS = null;
let bgm = null;
let currentBgmUrl = null;
let footstepLoop = null;
let attackSound = null;
let potionSound = null;
let wallAssets = {};
let floorAssets = {};
let ceilingAssets = {};

const INITIAL_MAP_URL = "https://xch-devci.github.io/One-Dungeon/maps/godness.json";

async function loadAssets() {
    try {
        const res = await fetch("https://xch-devci.github.io/One-Dungeon/assets/assets.json");
        ASSETS = await res.json();
        console.log("Assets loaded:", ASSETS);

        // audio
        if (ASSETS.audio?.footstep) {
            footstepLoop = new Audio(ASSETS.audio.footstep);
            footstepLoop.loop = true;
            footstepLoop.volume = 0.95;
        }
        if (ASSETS.audio?.attack) {
            attackSound = new Audio(ASSETS.audio.attack);
            attackSound.loop = false;
            attackSound.volume = 0.9;
        }
        if (ASSETS.audio?.potion) {
            potionSound = new Audio(ASSETS.audio.potion);
            potionSound.loop = false;
            potionSound.volume = 0.9;
        }

    } catch (err) {
        console.error("Failed to load assets.json", err);
    }
}

let currentMapUrl = INITIAL_MAP_URL;

async function loadMaps(url = INITIAL_MAP_URL) {
    try {
        currentMapUrl = url;
        const res = await fetch(url);
        const data = await res.json();

        // size
        MAP_SIZE = data.MAP_SIZE ?? (data.wallMap?.length || 0);
        HALF_MAP = MAP_SIZE / 2;
        
        // BGM handling
        if (data.bgm) {
            if (bgm && currentBgmUrl === data.bgm) {
                bgm.loop = true;
                bgm.volume = 0.03;
            } else {
                if (bgm) {
                    bgm.pause();
                }
                bgm = new Audio(data.bgm);
                bgm.loop = true;
                bgm.volume = 0.03;
                currentBgmUrl = data.bgm;
            }
        } else {
            if (bgm) {
                bgm.pause();
                bgm = null;
            }
            currentBgmUrl = null;
        }
        
        // light layer, fallback to all "."
        if (data.lightMap) {
            lightMap = data.lightMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            lightMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        // portal layer, fallback to all "."
        if (data.portalMap) {
            portalMap = data.portalMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            portalMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        if (data.structureMap) {
            structureMap = data.structureMap;
        } else {
            const row = ".".repeat(MAP_SIZE);
            structureMap = Array.from({ length: MAP_SIZE }, () => row);
        }

        // portals definition (label -> { url })
        portals = data.portals || {};
        
        structuresDefs = data.structures || {};
        
        groundMap = data.groundMap;
        ceilingMap = data.ceilingMap || data.groundMap;
        wallMap = data.wallMap;
        objectMap = data.objectMap;

        // per map assets, fall back to global ASSETS if not provided
        wallAssets   = data.walls    || (ASSETS?.walls    || {});
        floorAssets  = data.floors   || (ASSETS?.floors   || {});
        ceilingAssets = data.ceilings || (ASSETS?.ceilings || {});

        console.log("Maps loaded:", {
            url,
            MAP_SIZE,
            lightMapPreview: lightMap[0],
            portalMapPreview: portalMap[0],
            structureMapPreview: structureMap[0],
            portals,
            structuresDefs,
            bgm: data.bgm,
            wallAssets,
            floorAssets,
            ceilingAssets
        });
    } catch (err) {
        console.error("Failed to load maps.json", err);
    }
}

const LIGHT_TYPES = {
    R: {
        color: new BABYLON.Color3(1.0, 0.3, 0.3),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    B: {
        color: new BABYLON.Color3(0.4, 0.6, 1.0),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    G: {
        color: new BABYLON.Color3(0.4, 1.0, 0.4),
        intensity: 1.8,
        range: 14,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    Y: {
        color: new BABYLON.Color3(1.0, 0.9, 0.4),
        intensity: 2.0,
        range: 15,
        angle: Math.PI / 1.2,
        exponent: 1.1
    },
    W: {
        color: new BABYLON.Color3(1.0, 1.0, 1.0),
        intensity: 2.3,
        range: 15,
        angle: Math.PI / 1.2,
        exponent: 1.1
    }
};

/* ============================================================
   Base variables and Babylon setup
   ============================================================ */

const player = { maxHp: 100, hp: 100 };

const BASE_TORCH_INTENSITY = 1.25;
let torchTime = 0;

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
engine.setHardwareScalingLevel(1.3);

canvas.addEventListener("contextmenu", e => e.preventDefault());

let scene, camera, playerLight;

canvas.addEventListener("pointerup", () => {
    clearAllHeldButtons();
});
canvas.addEventListener("pointercancel", () => {
    clearAllHeldButtons();
});
canvas.addEventListener("pointerleave", () => {
    clearAllHeldButtons();
});

canvas.addEventListener("touchend", e => {
    e.preventDefault();
    clearAllHeldButtons();
}, { passive: false });

canvas.addEventListener("touchcancel", e => {
    e.preventDefault();
    clearAllHeldButtons();
}, { passive: false });

let MAP_SIZE = 0;
const TILE_SIZE = 2;
let HALF_MAP = 0;

const FLOOR_THICKNESS = 0.2;
const WALL_HEIGHT = 3;
const CEILING_THICKNESS = 0.2;
const CEILING_Y = WALL_HEIGHT;

const CAMERA_HEIGHT = 1.4;
const PLAYER_RADIUS = 0.75;

let wantFootsteps = false;

/* GUI elements (Babylon GUI) */
let guiTexture = null;
let hpText = null;

/* ============================================================
   MAPS - loaded from maps.json
   ============================================================ */

let groundMap = [];
let ceilingMap = [];
let wallMap = [];
let objectMap = [];
let lightMap = [];
let portalMap = [];
let structureMap = [];
let portals = {};
let structuresDefs = {};
let portalCooldown = 0;
let mapDefaultSpawn = null;

/* ============================================================
   Helpers
   ============================================================ */

function gridToWorld(i, j) {
    const x = (j - HALF_MAP + 0.5) * TILE_SIZE;
    const z = (i - HALF_MAP + 0.5) * TILE_SIZE;
    return new BABYLON.Vector3(x, 0, z);
}

function worldToGrid(x, z) {
    const j = Math.floor(x / TILE_SIZE + HALF_MAP);
    const i = Math.floor(z / TILE_SIZE + HALF_MAP);
    return { i, j };
}
    
function teleportPlayerToSpawn(spawn) {
    if (!spawn) return;
    if (typeof spawn.i !== "number" || typeof spawn.j !== "number") return;

    const pos = gridToWorld(spawn.i, spawn.j);

    camera.position.x = pos.x;
    camera.position.y = CAMERA_HEIGHT;
    camera.position.z = pos.z;
}

function placePlayerAfterMapLoad(entrySpawn) {
    if (entrySpawn) {
        teleportPlayerToSpawn(entrySpawn);
        return;
    }

    if (mapDefaultSpawn) {
        teleportPlayerToSpawn(mapDefaultSpawn);
        return;
    }
}

/* ============================================================
   Monster System with status (idle, walk, run, attack)
   ============================================================ */

const monsters = [];

function setMonsterStatus(mon, newStatus) {
    if (mon.status === newStatus) return;

    let name = newStatus;
    let sDef = mon.statusDefs[name];

    if (!sDef) {
        if (name === "run" && mon.statusDefs.walk)        name = "walk";
        else if (name === "walk" && mon.statusDefs.idle)  name = "idle";
        else if (name === "attack" && mon.statusDefs.run) name = "run";

        sDef = mon.statusDefs[name] ||
               mon.statusDefs.idle ||
               Object.values(mon.statusDefs)[0];
    }

    if (!sDef) return;

    mon.status = name;
    mon.frames = sDef.frames;
    mon.cols = sDef.cols;
    mon.rows = sDef.rows;
    mon.animFrame = 0;
    mon.animTime = 0;

    const mat = mon.mesh.material;
    mat.diffuseTexture = sDef.texture;

    if (name === "idle")      mon.animSpeed = 3;
    else if (name === "walk") mon.animSpeed = 6;
    else if (name === "run")  mon.animSpeed = 10;
    else if (name === "attack") mon.animSpeed = 8;
}

function createMonster(scene, worldPos, type) {
    const conf = ASSETS.monsters?.[type];
    if (!conf) return null;

    const plane = BABYLON.MeshBuilder.CreatePlane(
        "monster_" + type,
        { size: conf.scale ?? 2.4 },
        scene
    );

    plane.position = new BABYLON.Vector3(worldPos.x, 1.1, worldPos.z);
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

    const mat = new BABYLON.StandardMaterial("monsterMat_" + type, scene);
    mat.backFaceCulling = false;
    mat.useAlphaFromDiffuseTexture = true;
    mat.maxSimultaneousLights = 8;
    plane.material = mat;

    const statusDefs = {};
    const statusTable = conf.status || {};

    for (const [name, sConf] of Object.entries(statusTable)) {
        const cols = sConf.cols || 1;
        const rows = sConf.rows || 1;
        const frames = sConf.frames || (cols * rows);

        const tex = new BABYLON.Texture(sConf.sprite, scene);
        tex.hasAlpha = true;
        tex.uScale = 1 / cols;
        tex.vScale = 1 / rows;
        tex.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
        tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;

        statusDefs[name] = { texture: tex, cols, rows, frames };
    }

    if (Object.keys(statusDefs).length === 0) {
        console.warn("Monster has no status animations:", type);
        return null;
    }

    const monster = {
        mesh: plane,
        type,
        hp: conf.maxHp ?? 50,
        maxHp: conf.maxHp ?? 50,
        alive: true,
        cooldown: 0,

        statusDefs,
        status: null,

        animFrame: 0,
        animTime: 0,
        animSpeed: conf.animSpeed ?? 6,
        frames: 1,
        cols: 1,
        rows: 1,

        detectRange: conf.detectRange ?? 8,
        attackRange: conf.attackRange ?? 1.5,
        walkSpeed: conf.speed ?? 1.2,
        runSpeed: conf.runSpeed ?? ((conf.speed ?? 1.2) * 1.8),
        idleRadius: conf.idleRadius ?? 3.0,

        attackDamage: conf.attackDamage ?? 4,
        radius: conf.radius ?? 0.4,

        idleCenter: plane.position.clone(),
        wanderTarget: null,
        wanderCooldown: 0
    };

    setMonsterStatus(monster, "idle");

    return monster;
}

function spawnMonsters(scene) {
    monsters.length = 0;
    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const sym = objectMap[i][j];
            if (!ASSETS.monsters || !ASSETS.monsters[sym]) continue;

            const pos = gridToWorld(i, j);
            const monster = createMonster(scene, pos, sym);
            if (monster) monsters.push(monster);
        }
    }
}

function spawnStructures(scene) {
    if (!structureMap || !structureMap.length) return;
    if (!structuresDefs || Object.keys(structuresDefs).length === 0) {
        console.log("No structures defined for this map.");
        return;
    }

    console.log("Spawning structures...");

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const ch = structureMap[i]?.[j];
            if (!ch || ch === ".") continue;

            const sConf = structuresDefs[ch];
            if (!sConf || !sConf.url) {
                console.warn("Structure char", ch, "has no config/url");
                continue;
            }

            const pos = gridToWorld(i, j);
            const fullUrl = sConf.url;
            if (typeof fullUrl !== "string" || !fullUrl.length) continue;

            const lastSlash = fullUrl.lastIndexOf("/");
            const rootUrl   = fullUrl.substring(0, lastSlash + 1);
            const fileName  = fullUrl.substring(lastSlash + 1);

            try {
                BABYLON.SceneLoader.ImportMesh(
                    "",
                    rootUrl,
                    fileName,
                    scene,
                    (meshes) => {
                        if (!meshes || !meshes.length) {
                            console.warn("No meshes loaded for structure", ch, "at", i, j);
                            return;
                        }

                        const root = new BABYLON.TransformNode(
                            `struct_${ch}_${i}_${j}`,
                            scene
                        );
                        meshes.forEach(m => {
                            m.parent = root;
                        });

                        const basePos = pos;
                        root.position = new BABYLON.Vector3(
                            basePos.x + (sConf.offsetX || 0),
                            0,
                            basePos.z + (sConf.offsetZ || 0)
                        );

                        const sc = sConf.scale ?? 1;
                        root.scaling = new BABYLON.Vector3(sc, sc, sc);

                        const bbox = root.getHierarchyBoundingVectors();
                        const lowestY = bbox.min.y;
                        root.position.y -= lowestY;

                        if (typeof sConf.y === "number") {
                            root.position.y += sConf.y;
                        }

                        if (typeof sConf.rotationY === "number") {
                            root.rotation = new BABYLON.Vector3(0, sConf.rotationY, 0);
                        }

                        console.log("Structure loaded", ch, "at", root.position, "scale", sc);
                    },
                    null,
                    (scene, message, exception) => {
                        console.error("ImportMesh error (async):", message, exception);
                    }
                );
            } catch (e) {
                console.error("ImportMesh error (sync):", e);
            }
        }
    }

    console.log("spawnStructures finished");
}

// ========================================================
// Procedural Noise Skybox Shader
// ========================================================
BABYLON.Effect.ShadersStore["noiseSkyboxVertexShader"] = `
    precision highp float;
    
    attribute vec3 position;
    uniform mat4 worldViewProjection;

    varying vec3 vPosition;

    void main(void) {
        vPosition = position;
        gl_Position = worldViewProjection * vec4(position, 1.0);
    }
`;

BABYLON.Effect.ShadersStore["noiseSkyboxFragmentShader"] = `
precision highp float;

uniform float time;
varying vec3 vPosition;

// -------------------------------
// Hash
// -------------------------------
float hash(vec3 p){
    p = fract(p * 0.3183099 + 0.1);
    p *= 17.0;
    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}

// -------------------------------
// Noise
// -------------------------------
float noise(vec3 p){
    vec3 i = floor(p);
    vec3 f = fract(p);

    return mix(
        mix(
            mix(hash(i+vec3(0,0,0)), hash(i+vec3(1,0,0)), f.x),
            mix(hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)), f.x),
        f.y),
        mix(
            mix(hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)), f.x),
            mix(hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)), f.x),
        f.y),
    f.z);
}

// -------------------------------
// fBM
// -------------------------------
float fbm(vec3 p){
    float v = 0.0;
    float a = 0.5;
    for(int i=0; i<5; i++){
        v += a * noise(p);
        p = p * 2.5 + vec3(1.3, 2.4, 0.7);
        a *= 0.5;
    }
    return v;
}

// --------------------------------------------
// Vortex noise ‚Äì spiraling fractal galaxy
// --------------------------------------------
float vortex(vec2 uv, float spin){
    float angle = atan(uv.y, uv.x);
    float r = length(uv);

    angle += spin * (1.0 / max(r, 0.05));
    vec2 p = vec2(cos(angle), sin(angle)) * r;

    float n1 = fbm(vec3(p*3.0, time*0.2));
    float n2 = fbm(vec3(p*6.0 + vec2(1.0,2.0), time*0.4));

    return n1*0.6 + n2*0.4;
}

// =======================================================
// MULTIPLE RIFT POSITIONS
// =======================================================
vec2 riftPos[3];
void initRifts() {
    riftPos[0] = vec2(-0.4, 0.25);
    riftPos[1] = vec2( 0.35, -0.2);
    riftPos[2] = vec2( 0.15, 0.55);
}

void main(){
    initRifts();

    vec3 dir = normalize(vPosition);
    vec2 uv = dir.xz;
    float t = time * 0.3;

    // --------------------------------------------------
    // Background nebula
    // --------------------------------------------------
    float neb = fbm(vec3(dir*3.0 + time*0.05));

    vec3 deep = vec3(0.01, 0.0, 0.03);
    vec3 purple = vec3(0.45, 0.0, 0.6);
    vec3 blue = vec3(0.2, 0.3, 1.0);

    vec3 col = mix(deep, purple, neb);
    col = mix(col, blue, pow(neb, 2.5));

    // --------------------------------------------------
    // MULTI-RIFT RENDERING
    // --------------------------------------------------
    for(int i=0; i<3; i++){
        float dist = length(uv - riftPos[i]);

        // pulsation
        float pulse = 0.15 + 0.1 * sin(time*4.0 + float(i)*1.7);
        float riftMask = smoothstep(0.35 + pulse, 0.12, dist);

        // INSIDE THE RIFT = NEW UNIVERSE
        // galaxy-like vortex
        float spin = (i==0 ? 1.5 : (i==1 ? -2.2 : 0.8));
        float galaxy = vortex((uv - riftPos[i]) * 3.0, spin);

        // color of alternate dimension
        vec3 universeColor = mix(
            vec3(0.05, 0.1, 0.25),
            vec3(0.8, 0.3, 1.7),
            pow(galaxy, 2.0)
        );

        // blend into main sky
        col = mix(col, universeColor, riftMask);

        // bright glowing edges
        float edge = smoothstep(0.18, 0.12, dist);
        col += vec3(1.2, 0.4, 2.0) * edge * 0.7;
    }

    gl_FragColor = vec4(col, 1.0);
}
`;

BABYLON.Effect.ShadersStore["procWallVertexShader"] = `
precision highp float;
attribute vec3 position;
attribute vec2 uv;
uniform mat4 worldViewProjection;
varying vec2 vUV;
void main(void){
    vUV = uv * 4.0;   // ÊîæÂ§ß UV ËÆìÁ£öËºÉÂ∞è
    gl_Position = worldViewProjection * vec4(position,1.0);
}
`;

BABYLON.Effect.ShadersStore["procWallFragmentShader"] = `
precision highp float;
varying vec2 vUV;

void main() {
    vec2 uv = vUV;

    // ========================================
    // BRICK GEOMETRY
    // ========================================
    float brickW = 1.0;
    float brickH = 0.5;

    float row = floor(uv.y / brickH);
    float offset = mod(row, 2.0) * (brickW * 0.5);
    uv.x += offset;

    float bx = fract(uv.x / brickW);
    float by = fract(uv.y / brickH);

    // ========================================
    // COLOR DEFINITIONS
    // ========================================
    vec3 HARD_MORTAR = vec3(0.0);      // pure black
    vec3 SOFT_MORTAR = vec3(0.15);     // dark gray
    vec3 BRICK       = vec3(0.85);     // LIGHTER gray interior

    // ========================================
    // HARD MORTAR BORDER (BLACK)
    // ========================================
    float border = 0.04;
    float hardBorder =
        step(bx, border) +
        step(1.0 - bx, border) +
        step(by, border) +
        step(1.0 - by, border);

    // ========================================
    // SOFT BEVEL (INNER SHADING)
    // DARK -> LIGHT ‚Üí toward center
    // ========================================
    float distX = min(bx, 1.0 - bx);
    float distY = min(by, 1.0 - by);
    float inner = min(distX, distY);

    float bevel = smoothstep(0.18, 0.0, inner);

    vec3 brickWithBevel = mix(SOFT_MORTAR, BRICK, bevel);

    // ========================================
    // HARD BORDER OVERWRITES EVERYTHING
    // ========================================
    vec3 finalColor = mix(brickWithBevel, HARD_MORTAR, clamp(hardBorder, 0.0, 1.0));

    gl_FragColor = vec4(finalColor, 1.0);
}
`;


BABYLON.Effect.ShadersStore["procFloorVertexShader"] = `
precision highp float;
attribute vec3 position;
attribute vec2 uv;
uniform mat4 worldViewProjection;
varying vec2 vUV;

void main(void){
    // Scale UV but LESS than wall ‚Üí bricks look LARGER
    vUV = uv * 2.0;   // ‚Üê try 1.5, 2.0, 3.0 depending on size you want
    gl_Position = worldViewProjection * vec4(position,1.0);
}
`;

BABYLON.Effect.ShadersStore["procFloorFragmentShader"] = `
precision highp float;
varying vec2 vUV;

float hash(vec2 p){
    return fract(sin(dot(p, vec2(23.1, 91.7))) * 43758.5453);
}

float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0,0.0));
    float c = hash(i + vec2(0.0,1.0));
    float d = hash(i + vec2(1.0,1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

float fbm(vec2 p){
    float v = 0.0;
    float a = 0.5;
    for (int i=0; i<4; i++){
        v += a * noise(p);
        p = p * 2.0 + 3.1;
        a *= 0.5;
    }
    return v;
}

void main(){
    vec2 uv = vUV;

    // Larger brick tiles
    float brickW = 2.0;
    float brickH = 2.0;

    float bx = fract(uv.x / brickW);
    float by = fract(uv.y / brickH);

    // Base stone color
    vec3 brickColor = vec3(0.15, 0.16, 0.17);
    vec2 brickID = floor(vec2(uv.x / brickW, uv.y / brickH));

    float var = fbm(brickID * 1.8);
    brickColor *= 0.85 + var * 0.25;

    float edgeX = min(bx, 1.0 - bx);
    float edgeY = min(by, 1.0 - by);
    float edge = smoothstep(0.0, 0.25, edgeX * edgeY);
    brickColor *= mix(0.8, 1.1, edge);

    gl_FragColor = vec4(brickColor, 1.0);
}
`;

/* ============================================================
   PNG ‚Üí PIXELS ‚Üí VOXELS ‚Üí 3D OBJECT
   ============================================================ */

// 1. Load PNG pixels
async function loadImagePixels(url) {
    return new Promise(resolve => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");

            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, img.width, img.height);

            resolve({
                width: img.width,
                height: img.height,
                data: imageData.data
            });
        };
        img.src = url;
    });
}

// 2. PNG ‚Üí voxel 3D array
function pngToVoxels(img) {
    const { width, height, data } = img;

    const voxels = [];

    for (let x = 0; x < width; x++) {
        voxels[x] = [];
        for (let y = 0; y < height; y++) {
            const idx = (y * width + x) * 4;

            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            const a = data[idx + 3];

            // Only create block if pixel is not transparent
            voxels[x][height - 1 - y] = [{
                exists: a > 20,
                color: { r, g, b }
            }];
        }
    }

    return voxels;
}

// 3. Build voxel mesh inside BabylonJS scene
function buildVoxels(voxels, scene, worldX, worldY, worldZ, scale = 0.15) {
    const base = BABYLON.MeshBuilder.CreateBox("voxelBase", { size: 1 }, scene);
    base.isVisible = false;

    const sizeX = voxels.length;
    const sizeY = voxels[0].length;
    const sizeZ = voxels[0][0].length;

    for (let x = 0; x < sizeX; x++) {
        for (let y = 0; y < sizeY; y++) {
            for (let z = 0; z < sizeZ; z++) {
                const v = voxels[x][y][z];
                if (!v.exists) continue;

                const inst = base.createInstance(`vx_${x}_${y}_${z}`);
                inst.position.set(
                    worldX + x * scale,
                    worldY + y * scale,
                    worldZ + z * scale
                );
                inst.scaling.set(scale, scale, scale);

                const mat = new BABYLON.StandardMaterial("vm", scene);
                mat.diffuseColor = new BABYLON.Color3(v.color.r / 255, v.color.g / 255, v.color.b / 255);
                inst.material = mat;
            }
        }
    }
}

/* ============================================================
   Scene - JSON driven walls/floors/ceilings
   plus Babylon GUI for HP and controls
   ============================================================ */
let skyMat = null;
let wallShader = null;
let floorShader = null;
    
function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    // ========================================================
    // Procedural Skybox Cube
    // ========================================================
    const skybox = BABYLON.MeshBuilder.CreateBox("noiseSkybox", { size: 500 }, scene);
    skybox.infiniteDistance = true;
    
    skyMat = new BABYLON.ShaderMaterial("noiseSkyMat", scene, {
        vertex: "noiseSkybox",
        fragment: "noiseSkybox",
    }, {
        needAlphaBlending: false,
        needAlphaTesting: false,
    });

    wallShader = new BABYLON.ShaderMaterial("wallShader", scene, {
        vertex: "procWall",
        fragment: "procWall"
    }, {
        attributes: ["position", "uv"],
        uniforms: ["worldViewProjection", "time"]
    });

    floorShader = new BABYLON.ShaderMaterial("floorShader", scene, {
        vertex: "procFloor",
        fragment: "procFloor"
    }, {
        attributes: ["position", "uv"],
        uniforms: ["worldViewProjection"]
    });
    
    // No lighting & culling
    skyMat.backFaceCulling = false;
    skyMat.disableLighting = true;
    
    skybox.material = skyMat;
        
    // camera
    camera = new BABYLON.UniversalCamera(
        "playerCamera",
        new BABYLON.Vector3(0, CAMERA_HEIGHT, -8),
        scene
    );
    camera.inertia = 0;
    camera.checkCollisions = false;
    camera.minZ = 0.01;

    // lights
    const sun = new BABYLON.DirectionalLight(
        "sunLight",
        new BABYLON.Vector3(-0.3, -1.0, -0.2),
        scene
    );
    sun.position = new BABYLON.Vector3(0, 50, 0);
    sun.intensity = 0.4;
    sun.diffuse  = new BABYLON.Color3(1.0, 0.98, 0.9);
    sun.specular = new BABYLON.Color3(1.0, 1.0, 1.0);
    
    const hemi = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    hemi.intensity = 0.1;

    playerLight = new BABYLON.PointLight(
        "playerTorch",
        new BABYLON.Vector3(0.5, 0.5, 1.1),
        scene
    );
    playerLight.parent = camera;
    playerLight.range = 12.5;
    playerLight.intensity = BASE_TORCH_INTENSITY;
    playerLight.diffuse  = new BABYLON.Color3(1.2, 0.92, 0.72);
    playerLight.specular = new BABYLON.Color3(0.35, 0.28, 0.22);
    playerLight.falloffType = BABYLON.Light.FALLOFF_STANDARD;

    const wallOps = { width: TILE_SIZE, depth: TILE_SIZE, height: WALL_HEIGHT, wrap: true };
    const floorOps = { width: TILE_SIZE, depth: TILE_SIZE, height: FLOOR_THICKNESS };
    const ceilOps  = { width: TILE_SIZE, depth: TILE_SIZE, height: CEILING_THICKNESS };

    mapDefaultSpawn = null;
    let debugLightCount = 0;

    for (let i = 0; i < MAP_SIZE; i++) {
        for (let j = 0; j < MAP_SIZE; j++) {
            const pos = gridToWorld(i, j);

            // FLOOR
            const floorChar = groundMap[i][j];
            const floorUrl  = floorAssets?.[floorChar];
            const f = BABYLON.MeshBuilder.CreateBox(`f${i}_${j}`, floorOps, scene);
            f.position = new BABYLON.Vector3(pos.x, -FLOOR_THICKNESS / 2, pos.z);
            f.material = floorShader;

            // WALL
            const tile = wallMap[i][j];
            const wallUrl = wallAssets?.[tile];
            if (wallUrl) {
                const w = BABYLON.MeshBuilder.CreateBox(`w${i}_${j}`, wallOps, scene);
                w.position = new BABYLON.Vector3(pos.x, WALL_HEIGHT / 2, pos.z);
                w.material = wallShader;
            }

            // LIGHTS from lightMap
            const lightChar = lightMap[i]?.[j];
            if (lightChar && lightChar !== ".") {
                const cfg = LIGHT_TYPES[lightChar];
                if (cfg) {
                    const lightPos = new BABYLON.Vector3(pos.x, CEILING_Y - 0.1, pos.z);
                    const lightDir = new BABYLON.Vector3(0, -1, 0);

                    const light = new BABYLON.SpotLight(
                        `light_${i}_${j}`,
                        lightPos,
                        lightDir,
                        cfg.angle,
                        cfg.exponent,
                        scene
                    );

                    light.diffuse  = cfg.color;
                    light.specular = cfg.color.scale(0.4);
                    light.intensity = cfg.intensity;
                    light.range = cfg.range;
                    light.falloffType = BABYLON.Light.FALLOFF_STANDARD;

                    debugLightCount++;
                }
            }
            
            // Player spawn
            if (objectMap[i][j] === "P") {
                mapDefaultSpawn = { i, j };
            }
        }
    }

    console.log("Map lights created:", debugLightCount, "scene lights:", scene.lights.length);

    /* ---------------- Babylon GUI: HP text and compact controls ---------------- */

    guiTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene);

    // HP text at top center
    hpText = new BABYLON.GUI.TextBlock("hpText", "Player HP: 100/100");
    hpText.color = "white";
    hpText.fontSize = 22;
    hpText.outlineWidth = 3;
    hpText.outlineColor = "black";
    hpText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    hpText.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
    hpText.paddingTop = "8px";
    guiTexture.addControl(hpText);

    // Controller group ‚Äì small box at bottom center
    const controller = new BABYLON.GUI.Grid();
    controller.width = "70%";
    controller.height = "40%";
    controller.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    controller.verticalAlignment   = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    controller.paddingBottom = "18%";
    controller.addRowDefinition(0.5);
    controller.addRowDefinition(0.5);
    controller.addColumnDefinition(0.25);
    controller.addColumnDefinition(0.25);
    controller.addColumnDefinition(0.25);
    controller.addColumnDefinition(0.25);
    controller.background = "rgba(0,0,0,0)";
    controller.thickness = 0;
    guiTexture.addControl(controller);

    function styleButton(btn) {
        btn.color = "white";
        btn.fontSize = 26;
        btn.thickness = 0;
        btn.cornerRadius = 0;
        btn.background = "rgba(0,0,0,0)";
    }

    // hold-button helper
    function createHoldButton(name, label, onDown, onUp) {
        const btn = BABYLON.GUI.Button.CreateSimpleButton(name, label);
        styleButton(btn);
        btn.onPointerDownObservable.add(() => onDown(true));
        const release = () => onUp(false);
        btn.onPointerUpObservable.add(release);
        btn.onPointerOutObservable.add(release);
        return btn;
    }

    // tap-button helper (attack, potion)
    function createTapButton(name, label, onTap) {
        const btn = BABYLON.GUI.Button.CreateSimpleButton(name, label);
        styleButton(btn);
        btn.onPointerUpObservable.add(() => onTap());
        return btn;
    }

    // row 0: attack, forward, potion
    const btnAttack = createTapButton("btnAttack", "‚öî", performAttack);
    const btnForward = createHoldButton(
        "btnForward", "‚Üë",
        v => btnForwardHeld = v,
        v => btnForwardHeld = v
    );
    const btnPotion = createTapButton("btnPotion", "üß™", performPotion);
    const btnLookUp = createHoldButton(
        "btnLookUp", "‚§í",
        v => btnLookUpHeld = v,
        v => btnLookUpHeld = v
    );
    
    controller.addControl(btnAttack, 0, 0);
    controller.addControl(btnForward, 0, 1);
    controller.addControl(btnPotion, 0, 2);
    controller.addControl(btnLookUp, 0, 3);

    // row 1: turn left, back, turn right
    const btnTurnLeft = createHoldButton(
        "btnTurnLeft", "‚Ü∫",
        v => btnTurnLeftHeld = v,
        v => btnTurnLeftHeld = v
    );
    const btnBack = createHoldButton(
        "btnBack", "‚Üì",
        v => btnBackHeld = v,
        v => btnBackHeld = v
    );
    const btnTurnRight = createHoldButton(
        "btnTurnRight", "‚Üª",
        v => btnTurnRightHeld = v,
        v => btnTurnRightHeld = v
    );
    const btnLookDown = createHoldButton(
        "btnLookDown", "‚§ì",
        v => btnLookDownHeld = v,
        v => btnLookDownHeld = v
    );

    controller.addControl(btnTurnLeft, 1, 0);
    controller.addControl(btnBack,     1, 1);
    controller.addControl(btnTurnRight,1, 2);
    controller.addControl(btnLookDown,1, 3);
    
    scene.onPointerUp = () => {
        clearAllHeldButtons();
    };
    scene.onPointerOut = () => {
        clearAllHeldButtons();
    };

    return scene;
}

/* ============================================================
   Movement and collision
   ============================================================ */

const MOVE_SPEED = 4;
const TURN_SPEED = Math.PI;

function isObstacleTile(i, j) {
    const wallTile = wallMap[i]?.[j];
    if (wallAssets && wallTile && (wallTile in wallAssets)) {
        return true;
    }

    const sChar = structureMap[i]?.[j];
    if (sChar && sChar !== "." && structuresDefs && structuresDefs[sChar]) {
        const sConf = structuresDefs[sChar];
        if (sConf.solid !== false) {
            return true;
        }
    }

    return false;
}

function isCircleCollidingWithWalls(pos, radius = PLAYER_RADIUS) {
    const g = worldToGrid(pos.x, pos.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return true;

    for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
            const wi = g.i + di;
            const wj = g.j + dj;
            if (wi < 0 || wi >= MAP_SIZE || wj < 0 || wj >= MAP_SIZE) continue;

            if (!isObstacleTile(wi, wj)) continue;

            const xMin = (wj - HALF_MAP) * TILE_SIZE;
            const xMax = xMin + TILE_SIZE;
            const zMin = (wi - HALF_MAP) * TILE_SIZE;
            const zMax = zMin + TILE_SIZE;

            const cx = Math.max(xMin, Math.min(pos.x, xMax));
            const cz = Math.max(zMin, Math.min(pos.z, zMax));

            const dx = pos.x - cx;
            const dz = pos.z - cz;

            if (dx * dx + dz * dz < radius * radius) {
                return true;
            }
        }
    }
    return false;
}

function tryMove(step) {
    let moved = false;

    const px = camera.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px)) {
        camera.position.x = px.x;
        moved = true;
    }

    const pz = camera.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz)) {
        camera.position.z = pz.z;
        moved = true;
    }

    return moved;
}

function tryMoveMonster(mon, step) {
    const r = mon.radius ?? 0.4;

    const px = mon.mesh.position.add(new BABYLON.Vector3(step.x, 0, 0));
    if (!isCircleCollidingWithWalls(px, r)) {
        mon.mesh.position.x = px.x;
    }

    const pz = mon.mesh.position.add(new BABYLON.Vector3(0, 0, step.z));
    if (!isCircleCollidingWithWalls(pz, r)) {
        mon.mesh.position.z = pz.z;
    }
}

/* ============================================================
   Input
   ============================================================ */

let btnForwardHeld = false;
let btnBackHeld = false;
let btnTurnLeftHeld = false;
let btnTurnRightHeld = false;
let btnLookUpHeld = false;
let btnLookDownHeld = false;

const keys = { forward: false, back: false, left: false, right: false };

function clearAllHeldButtons() {
    btnForwardHeld = false;
    btnBackHeld = false;
    btnTurnLeftHeld = false;
    btnTurnRightHeld = false;
    btnLookUpHeld = false;
    btnLookDownHeld = false; 
}
    
window.addEventListener("keydown", e => {
    if (e.key === "w" || e.key === "ArrowUp")    keys.forward = true;
    if (e.key === "s" || e.key === "ArrowDown")  keys.back    = true;
    if (e.key === "a" || e.key === "ArrowLeft")  keys.left    = true;
    if (e.key === "d" || e.key === "ArrowRight") keys.right   = true;

    // NEW CAMERA UP/DOWN
    if (e.key === "PageUp")   btnLookUpHeld = true;
    if (e.key === "PageDown") btnLookDownHeld = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "w" || e.key === "ArrowUp")    keys.forward = false;
    if (e.key === "s" || e.key === "ArrowDown")  keys.back    = false;
    if (e.key === "a" || e.key === "ArrowLeft")  keys.left    = false;
    if (e.key === "d" || e.key === "ArrowRight") keys.right   = false;

    // NEW CAMERA UP/DOWN release
    if (e.key === "PageUp")   btnLookUpHeld = false;
    if (e.key === "PageDown") btnLookDownHeld = false;
});


/* ============================================================
   Attack and potion actions
   ============================================================ */

function performAttack() {
    if (attackSound) {
        attackSound.currentTime = 0;
        attackSound.play().catch(() => {});
    }

    for (const m of monsters) {
        if (!m.alive) continue;

        const dx = camera.position.x - m.mesh.position.x;
        const dz = camera.position.z - m.mesh.position.z;
        const dist = Math.hypot(dx, dz);

        if (dist < 2.2) {
            m.hp -= 12;
            if (m.hp <= 0) {
                m.alive = false;
                m.mesh.dispose();
            }
        }
    }
}

function performPotion() {
    if (player.hp <= 0) return;

    player.hp = Math.min(player.maxHp, player.hp + 20);
    if (potionSound) {
        potionSound.currentTime = 0;
        potionSound.play().catch(() => {});
    }
}

/* ============================================================
   Monster animation
   ============================================================ */

function animateMonster(mon, dt) {
    if (!mon.frames || mon.frames <= 1) return;

    mon.animTime += dt;

    const frameDuration = 1 / mon.animSpeed;

    while (mon.animTime >= frameDuration) {
        mon.animFrame = (mon.animFrame + 1) % mon.frames;
        mon.animTime -= frameDuration;
    }

    const fx = mon.animFrame % mon.cols;
    const fy = Math.floor(mon.animFrame / mon.cols);

    const tex = mon.mesh.material.diffuseTexture;
    tex.uOffset = fx / mon.cols;
    tex.vOffset = fy / mon.rows;
}

/* ============================================================
   Monster AI with status
   ============================================================ */

function updateMonsterAI(mon, dt) {
    if (!mon.alive) return;

    const dx = camera.position.x - mon.mesh.position.x;
    const dz = camera.position.z - mon.mesh.position.z;
    const dist = Math.hypot(dx, dz);

    if (mon.cooldown > 0) mon.cooldown -= dt;
    if (mon.wanderCooldown > 0) mon.wanderCooldown -= dt;

    if (dist <= mon.attackRange) {
        setMonsterStatus(mon, "attack");
        mon.wanderTarget = null;

        if (mon.cooldown <= 0) {
            player.hp -= mon.attackDamage;
            if (player.hp < 0) player.hp = 0;
            mon.cooldown = 1.2;
        }
        return;
    }

    if (dist <= mon.detectRange) {
        setMonsterStatus(mon, "run");
        mon.wanderTarget = null;

        if (dist > 0.1) {
            const stepLen = mon.runSpeed * dt;
            const step = new BABYLON.Vector3((dx / dist) * stepLen, 0, (dz / dist) * stepLen);
            tryMoveMonster(mon, step);
        }
        return;
    }

    if (!mon.wanderTarget && mon.wanderCooldown <= 0) {
        if (Math.random() < 0.5) {
            setMonsterStatus(mon, "idle");
            mon.wanderCooldown = 1.5 + Math.random() * 2.0;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const radius = mon.idleRadius * Math.random();
            const tx = mon.idleCenter.x + Math.cos(angle) * radius;
            const tz = mon.idleCenter.z + Math.sin(angle) * radius;
            mon.wanderTarget = new BABYLON.Vector3(tx, mon.mesh.position.y, tz);
            setMonsterStatus(mon, "walk");
            mon.wanderCooldown = 2.0 + Math.random() * 3.0;
        }
    }

    if (mon.wanderTarget) {
        const tx = mon.wanderTarget.x - mon.mesh.position.x;
        const tz = mon.wanderTarget.z - mon.mesh.position.z;
        const dTarget = Math.hypot(tx, tz);

        if (dTarget < 0.1 || mon.wanderCooldown <= 0) {
            mon.wanderTarget = null;
        } else {
            const stepLen = mon.walkSpeed * dt;
            const step = new BABYLON.Vector3((tx / dTarget) * stepLen, 0, (tz / dTarget) * stepLen);
            tryMoveMonster(mon, step);
        }
    }
}

/* ============================================================
   Portals
   ============================================================ */

async function switchMap(portalCfg) {
    if (!portalCfg || !portalCfg.url) return;
    console.log("Switching map to", portalCfg.url, "spawn:", portalCfg.spawn);

    let preservedYaw = camera ? camera.rotation.y : 0;
    
    monsters.length = 0;
    
    if (scene) {
        scene.dispose();
    }

    await loadMaps(portalCfg.url);
    scene = createScene();

    camera.rotation.y = preservedYaw;
    
    spawnMonsters(scene);
    spawnStructures(scene);
    
    placePlayerAfterMapLoad(portalCfg.spawn);

    portalCooldown = 0.5;
}

function checkPortal() {
    if (portalCooldown > 0) return;
    if (!portalMap.length) return;

    const g = worldToGrid(camera.position.x, camera.position.z);
    if (g.i < 0 || g.i >= MAP_SIZE || g.j < 0 || g.j >= MAP_SIZE) return;

    const ch = portalMap[g.i]?.[g.j];
    if (!ch || ch === ".") return;

    const portalCfg = portals[ch];
    if (!portalCfg || !portalCfg.url) return;

    switchMap(portalCfg);
}

/* ============================================================
   Game Loop
   ============================================================ */

function update(dt) {
    if (wallShader) {
        wallShader.setFloat("time", performance.now() * 0.0001);
    }
    if (skyMat) {
        let t = performance.now() * 0.0001;
        skyMat.setFloat("time", t);
    }

    if (portalCooldown > 0) {
        portalCooldown -= dt;
        if (portalCooldown < 0) portalCooldown = 0;
    }

    if (btnTurnLeftHeld || keys.left)  camera.rotation.y -= TURN_SPEED * dt;
    if (btnTurnRightHeld || keys.right)camera.rotation.y += TURN_SPEED * dt;

    // CAMERA LOOK UP/DOWN
    const PITCH_SPEED = 1.2;  // adjust if too fast/slow
    
    if (btnLookUpHeld)   camera.rotation.x -= PITCH_SPEED * dt;
    if (btnLookDownHeld) camera.rotation.x += PITCH_SPEED * dt;
    
    // limit camera angle so player cannot flip upside down
    camera.rotation.x = BABYLON.Scalar.Clamp(camera.rotation.x, -Math.PI / 3, Math.PI / 3);

    const fwd = camera.getDirection(new BABYLON.Vector3(0, 0, 1));
    const flat = new BABYLON.Vector3(fwd.x, 0, fwd.z).normalize();
    const step = MOVE_SPEED * dt;

    let moved = false;
    if (btnForwardHeld || keys.forward) moved |= tryMove(flat.scale(step));
    if (btnBackHeld    || keys.back   ) moved |= tryMove(flat.scale(-step));

    wantFootsteps = moved;
    if (footstepLoop) {
        if (wantFootsteps && footstepLoop.paused) footstepLoop.play().catch(() => {});
        if (!wantFootsteps && !footstepLoop.paused) footstepLoop.pause();
    }

    checkPortal();

    torchTime += dt;
    const flicker =
        Math.sin(torchTime * 6.3) * 0.08 +
        Math.sin(torchTime * 11.1) * 0.05 +
        (Math.random() - 0.5) * 0.02;
    let intensity = BASE_TORCH_INTENSITY + flicker;
    intensity = Math.min(1.6, Math.max(0.95, intensity));
    playerLight.intensity = intensity;

    for (const m of monsters) {
        updateMonsterAI(m, dt);
        if (m.alive) animateMonster(m, dt);
    }

    if (hpText) {
        hpText.text = `Player HP: ${player.hp}/${player.maxHp}`;
    }
}

/* ============================================================
   Start the game
   ============================================================ */

(async () => {
    await loadAssets();
    await loadMaps(INITIAL_MAP_URL);

    scene = createScene();
    spawnMonsters(scene);
    spawnStructures(scene);

    placePlayerAfterMapLoad(null);

    engine.runRenderLoop(() => {
        const dt = engine.getDeltaTime() / 1000;
        update(dt);
        scene.render();

        if (bgm && bgm.paused) bgm.play().catch(() => {});
    });
})();

window.addEventListener("resize", () => {
    engine.resize();
});

window.addEventListener("click", () => {
    if (bgm && bgm.paused) bgm.play().catch(() => {});
});
</script>

</body>
</html>
